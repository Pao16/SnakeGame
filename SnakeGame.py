{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "83eed181-39a9-403b-9570-55f48a1a02e3",
   "metadata": {},
   "outputs": [],
   "source": [
    "import turtle\n",
    "import time\n",
    "import random\n",
    "\n",
    "class SnakeGame:\n",
    "\n",
    "    def __init__(self, width=600, height=600, color=\"green\"):\n",
    "        self._ancho = width\n",
    "        self._alto = height\n",
    "        \n",
    "        \"\"\"Inicializa los componentes del juego\"\"\"\n",
    "        \n",
    "        #Inicializa el lienzo de la pantalla\n",
    "        self.screen = turtle.Screen()\n",
    "        self.screen.title(\"Juego Snake\")\n",
    "        self.screen.bgcolor(color) #el usuario puede cambiar el color de la pantalla, por ello ponemos color en los paréntesis \n",
    "        self.screen.setup(width=width, height=height)\n",
    "        self.screen.tracer(0) #evita que se actualice automáticamente la pantalla\n",
    "        \n",
    "        #Inicializa la serpiente\n",
    "        self.snake = turtle.Turtle()\n",
    "        self.snake.speed(0) #Va automaticamente hacia arriba\n",
    "        self.snake.shape(\"square\")\n",
    "        self.snake.color(\"black\")\n",
    "        self.snake.penup()\n",
    "        self.snake.goto(0,0) #el punto en el que va a aparecer\n",
    "        \n",
    "        #inicialización de la comida de la serpiente\n",
    "        self.comida = turtle.Turtle()\n",
    "        self.comida.speed(0)\n",
    "        self.comida.shape(\"circle\")\n",
    "        self.comida.color(\"red\")\n",
    "        self.comida.penup()\n",
    "        self.comida.goto(0, 100)\n",
    "        \n",
    "        #Inicializa el texto que se muestra en la pantalla\n",
    "        self.texto = turtle.Turtle()\n",
    "        self.texto.speed(0)\n",
    "        self.texto.shape(\"square\")\n",
    "        self.texto.color(\"white\")\n",
    "        self.texto.penup()\n",
    "        self.texto.hideturtle() #este método oculta el puntero y deja solo el texto que ha sacado en pantalla\n",
    "        self.texto.goto(0,(height / 2) - 40)\n",
    "        #self._print_score() aqui todavía no está definida\n",
    "\n",
    "        #Atributos de la clase\n",
    "        self._direccion = None\n",
    "        self._delay = 0.1\n",
    "        self._score = 0\n",
    "        self._high_score = 0\n",
    "        self.snake_cuerpo = [] #Se van a guardar los cachos de cuerpo de la serpiente\n",
    "       \n",
    "        #Asociación de los movimientos y las teclas\n",
    "        self.screen.listen()\n",
    "        self.screen.onkeypress(self.arriba, \"w\")\n",
    "        self.screen.onkeypress(self.abajo, \"s\")\n",
    "        self.screen.onkeypress(self.izquierda, \"a\")\n",
    "        self.screen.onkeypress(self.derecha, \"d\")\n",
    "\n",
    "    def arriba(self):\n",
    "        \"\"\"Este metdo define el movimiento hacia arriba de la serpiente\"\"\" #Por el movimiento del juego, que si la serpiente va para \n",
    "        #abajo no puede ir de inmediato hacia arriba\n",
    "        \n",
    "        #Hay que definirlo para cada movimiento \n",
    "        \n",
    "        if self._direccion != \"abajo\":\n",
    "            self._direccion = \"arriba\" \n",
    "\n",
    "    def abajo(self):\n",
    "        if self._direccion != \"arriba\":\n",
    "            self._direccion = \"abajo\"\n",
    "\n",
    "    def izquierda(self):\n",
    "        if self._direccion != \"derecha\":\n",
    "            self._direccion = \"izquierda\"\n",
    "\n",
    "    def derecha(self):\n",
    "        if self._direccion != \"izquierda\":\n",
    "            self._direccion = \"derecha\"\n",
    "\n",
    "    def move(self):\n",
    "\n",
    "        #Para que el cuerpo de la serpiente siga a la cabeza necesitamos saber sus coordenadas\n",
    "        hx, hy = self.snake.xcor(), self.snake.ycor() #Así sabemos la coordenada x, y de la cabeza (o el 1er turtle)\n",
    "        #Movemos el cuerpo de la serpiente\n",
    "        for i in range(len(self.snake_cuerpo)-1,0,-1): #Mueve cada turtle a la posición del anterior\n",
    "            x = self.snake_cuerpo[i-1].xcor()\n",
    "            y = self.snake_cuerpo[i-1].ycor()\n",
    "            self.snake_cuerpo[i].goto(x,y)\n",
    "\n",
    "        #Mover el segmento más cercano a la cabeza\n",
    "        if len(self.snake_cuerpo) > 0:\n",
    "            self.snake_cuerpo[0].goto(hx,hy)\n",
    "\n",
    "        #Mueve la cabeza a donde nosotros queremos moverlo\n",
    "        if self._direccion == \"arriba\":\n",
    "            self.snake.sety(hy + 20)\n",
    "        elif self._direccion == \"abajo\":\n",
    "            self.snake.sety(hy - 20)\n",
    "        elif self._direccion == \"izquierda\":\n",
    "            self.snake.setx(hx - 20)\n",
    "        elif self._direccion == \"derecha\":\n",
    "            self.snake.setx(hx + 20)\n",
    "            \n",
    "  #Bucle infinito para jugar snakegame con las teclas, que se vaya movimiendo cuando pulso la tecla y no que espere a que la pulse muchas veces\n",
    "    def jugar(self):\n",
    "\n",
    "        while True:\n",
    "            self.screen.update() #Forza la actualizacion de la pantalla\n",
    "            self.colision_borde() #Usamos el método colision borde\n",
    "            self.colision_comida() #Usamos el método colisión comida en jugar\n",
    "            self.colision_cuerpo() #Usamos el método de colision del cuerpo\n",
    "            time.sleep(self._delay)\n",
    "            self.move()\n",
    "        self.screen.mainloop() #Mantiene la ventana abierta hasta que se cierra manualmente\n",
    "\n",
    "    def colision_borde(self):\n",
    "        bxcor = (self._ancho // 2) - 10\n",
    "        bycor = (self._alto // 2) - 10\n",
    "\n",
    "        if self.snake.xcor() > bxcor or self.snake.xcor() < -bxcor or self.snake.ycor() > bycor or self.snake.ycor() < -bycor:\n",
    "            self._reset()\n",
    "\n",
    "    def colision_cuerpo(self):\n",
    "        for s in self.snake_cuerpo:\n",
    "            if s.distance(self.snake) < 20:\n",
    "                self._reset()\n",
    "    \n",
    "            \n",
    "            \n",
    "\n",
    "    \n",
    "    def colision_comida(self):\n",
    "        if self.snake.distance(self.comida) < 20:\n",
    "            # Mover la comida a un lugar aleatorio\n",
    "            bxcor = (self._ancho // 2) - 10\n",
    "            bycor = (self._alto // 2) - 10\n",
    "            x = random.randint(-bxcor, bxcor)\n",
    "            y = random.randint(-bycor, bycor)\n",
    "            self.comida.goto(x,y)\n",
    "            #Si colisionamos con la comida entonces el cuerpo de la serpiente crece\n",
    "            self.incrementar_cuerpo()\n",
    "            #Reducir el delay\n",
    "            self._delay -= 0.001\n",
    "            #Aumentar el score\n",
    "            self._score += 10\n",
    "            self._print_score\n",
    "\n",
    "    #En cada colisión con la comida, el cuerpo de la snake aumentará, así que definimos una función que haga eso\n",
    "    def incrementar_cuerpo(self):\n",
    "        segmento = turtle.Turtle()\n",
    "        segmento.speed(0)\n",
    "        segmento.shape(\"square\")\n",
    "        segmento.color(\"grey\")\n",
    "        segmento.penup()\n",
    "        self.snake_cuerpo.append(segmento) #Lo agrega a la lista que hicimos en el apartado de atributos de la clase\n",
    "        \n",
    "\n",
    "    def _print_score(self):\n",
    "        self.texto.clear()\n",
    "        self.texto.write(\"Puntos: {} Record: {}\".format(self._score,self._high_score), align = 'center', font=(\"Courier\", 24, \"normal\"))\n",
    "            \n",
    "            \n",
    "    #Vamos a definir una función para la colisión con el cuerpo de la serpiente       \n",
    "    def _reset(self):\n",
    "        time.sleep(1)\n",
    "        self.snake.goto(0,0)\n",
    "        self._direction = None\n",
    "        #Reiniciar el cuerpo de la serpiente\n",
    "        for s in self.snake_cuerpo:\n",
    "            s.ht() #Oculta el segmento del cuerpo\n",
    "            #Limpiar la lista de segmentos\n",
    "        self.snake_cuerpo.clear()\n",
    "         #Reiniciar el delay\n",
    "        self._delay = 0.1\n",
    "            \n",
    "        #Reiniciar el score\n",
    "        if self._score > self._high_score:\n",
    "            self._high_score = self._score\n",
    "        self._score = 0\n",
    "            \n",
    "        #Sacamos el texto por pantalla\n",
    "        self._print_score()\n",
    "    \n",
    "        \n",
    "            \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "bba2d860-f9d1-4976-b828-59cc6aa8689b",
   "metadata": {},
   "outputs": [],
   "source": [
    "juego = SnakeGame()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "7d3c07bd-d03c-4924-9cfa-24f0eb068aeb",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-02-25 13:29:26.061 python[89467:3308927] +[IMKClient subclass]: chose IMKClient_Modern\n",
      "2025-02-25 13:29:31.073 python[89467:3308927] +[IMKInputSession subclass]: chose IMKInputSession_Modern\n"
     ]
    },
    {
     "ename": "Terminator",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTerminator\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[5], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m juego\u001b[38;5;241m.\u001b[39mjugar()\n",
      "Cell \u001b[0;32mIn[1], line 109\u001b[0m, in \u001b[0;36mSnakeGame.jugar\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    106\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mjugar\u001b[39m(\u001b[38;5;28mself\u001b[39m):\n\u001b[1;32m    108\u001b[0m     \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[0;32m--> 109\u001b[0m         \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mscreen\u001b[38;5;241m.\u001b[39mupdate() \u001b[38;5;66;03m#Forza la actualizacion de la pantalla\u001b[39;00m\n\u001b[1;32m    110\u001b[0m         \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcolision_borde() \u001b[38;5;66;03m#Usamos el método colision borde\u001b[39;00m\n\u001b[1;32m    111\u001b[0m         \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcolision_comida() \u001b[38;5;66;03m#Usamos el método colisión comida en jugar\u001b[39;00m\n",
      "File \u001b[0;32m/opt/anaconda3/lib/python3.12/turtle.py:1295\u001b[0m, in \u001b[0;36mTurtleScreen.update\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1293\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_tracing \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mTrue\u001b[39;00m\n\u001b[1;32m   1294\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m t \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mturtles():\n\u001b[0;32m-> 1295\u001b[0m     t\u001b[38;5;241m.\u001b[39m_update_data()\n\u001b[1;32m   1296\u001b[0m     t\u001b[38;5;241m.\u001b[39m_drawturtle()\n\u001b[1;32m   1297\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_tracing \u001b[38;5;241m=\u001b[39m tracing\n",
      "File \u001b[0;32m/opt/anaconda3/lib/python3.12/turtle.py:2654\u001b[0m, in \u001b[0;36mRawTurtle._update_data\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   2653\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m_update_data\u001b[39m(\u001b[38;5;28mself\u001b[39m):\n\u001b[0;32m-> 2654\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mscreen\u001b[38;5;241m.\u001b[39m_incrementudc()\n\u001b[1;32m   2655\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mscreen\u001b[38;5;241m.\u001b[39m_updatecounter \u001b[38;5;241m!=\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[1;32m   2656\u001b[0m         \u001b[38;5;28;01mreturn\u001b[39;00m\n",
      "File \u001b[0;32m/opt/anaconda3/lib/python3.12/turtle.py:1284\u001b[0m, in \u001b[0;36mTurtleScreen._incrementudc\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1282\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m TurtleScreen\u001b[38;5;241m.\u001b[39m_RUNNING:\n\u001b[1;32m   1283\u001b[0m     TurtleScreen\u001b[38;5;241m.\u001b[39m_RUNNING \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mTrue\u001b[39;00m\n\u001b[0;32m-> 1284\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m Terminator\n\u001b[1;32m   1285\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_tracing \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[1;32m   1286\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_updatecounter \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m \u001b[38;5;241m1\u001b[39m\n",
      "\u001b[0;31mTerminator\u001b[0m: "
     ]
    }
   ],
   "source": [
    "juego.jugar()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6fd76938-7f41-48fa-b9b7-3e1fa0ea59db",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
